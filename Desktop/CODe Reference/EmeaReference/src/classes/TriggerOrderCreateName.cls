public class TriggerOrderCreateName implements Triggers.Handler
{
    private static map<Id,User> userMap = new map<Id,User>();
    
    public static map<Id,User> getUsers(list<Id>users){
    
      list<Id>finalFilter = new list<Id>();
      map<id,User> result = new map<Id, User>();
      for (Id element: users){
      if (!userMap.keyset().contains(element))
      {
        finalFilter.add(element);
      }
      else{
        result.put(element,userMap.get(element));
      }
      }
      if(finalFilter.size() > 0)
      {
        list<User> newUsers = new list<User>([SELECT Id, OrderPrefix_RSA__c FROM User WHERE ID in :finalFilter ]);
        userMap.putAll(newUsers);
        result.putAll(newUsers);
      }
      
      return result;
    }
    
    public void handle()
    {
        List <Order__c> preliminaryOrders = new List <Order__c>();
        List <Order__c> finalOrders= new List <Order__c>();
        
        Map <Id, Decimal> LastFinalVersion = new Map <Id, Decimal>();
        
        for( Order__c oi: [
            SELECT 
                Id, Name , Version_Id_RSA__c , RecordTypeId , PreliminaryOrderRef_RSA__c
            FROM 
                Order__c 
            WHERE 
                OwnerId = :Util.currentUser.ID AND
                Name LIKE '%-%'
            ORDER BY
            	RecordTypeId DESC,
                CreatedDate DESC,
                Name DESC      
        ]) {
			//-----------------------------------
			// Different lists for final and preliminary orders, and also building
			// a map with the Id of the preliminary orders and the last version of
			// their corresponding final orders related.
			//-----------------------------------
            if(oi.RecordTypeId==Util.recordType.get('Order__c:PreliminaryOrder'))
            {
                preliminaryOrders.add(oi);
                LastFinalVersion.put(oi.Id, -1);
            }
            else
            {
                finalOrders.add(oi);
                Integer lastVersion = -1;
                
                if(LastFinalVersion.containsKey(oi.PreliminaryOrderRef_RSA__c))
                	lastVersion = Integer.valueOf(LastFinalVersion.get(oi.PreliminaryOrderRef_RSA__c)) + 1;

                LastFinalVersion.put(oi.PreliminaryOrderRef_RSA__c, lastVersion);
            }
        }

		//-----------------------------------
		// Getting the initials of the logged user
		//-----------------------------------
        Integer newNumber = 0;
        String initials;
        User usr = getUsers(new list<Id>{Util.currentUser.ID}).get(Util.currentUser.ID);
        initials = usr.OrderPrefix_RSA__c;
        integer count;

		//-----------------------------------
		// Preliminary orders are independent. There are no versions for preliminary orders.
		// It means that for new preliminary orders, their names will be generated by
		// getting the name of the most recent order and adding a number.
		//-----------------------------------
        if (preliminaryOrders.size () > 0)
        {
             Order__c ord = preliminaryOrders.get(0);
             newNumber = Integer.valueOf(ord.Name.split('-')[1]) + 1;
        }

        for (Order__c o : (List<Order__c>)Trigger.new)
        {      
            if(o.RecordTypeID == Util.recordType.get('Order__c:PreliminaryOrder'))
            {
                o.Name = String.valueOf(newNumber++);
                while (o.Name.length () < 5)
                {
                    o.Name = '0' + o.Name;
                }               
                o.Name = initials + '-' + o.Name;
            } else {
				//-----------------------------------
				// For final orders, their names come from the offline app, and they share the
				// name with their corresponding preliminary orders. So, only the version of
				// the orders change, and here we are getting the last version related to a
				// given order and adding a number for the new one.
				//-----------------------------------
                if(o.PreliminaryOrderRef_RSA__c != null)
                {
                    o.Version_Id_RSA__c = LastFinalVersion.get(o.PreliminaryOrderRef_RSA__c) + 1;
                    LastFinalVersion.put(o.PreliminaryOrderRef_RSA__c,o.Version_Id_RSA__c);
                } else 
                    o.Version_Id_RSA__c = 0;
            }
        }
    }
    
    public static testMethod void testHandle()
    {
        try
        {
            new TriggerOrderCreateName().handle();
        } catch(Exception e){}
    }
}